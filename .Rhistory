require(graphics)
library(debug)
## Annette Dobson (1998) "An Introduction to Generalized Linear Models"
## Page 9: Plant Weight Data
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2,10,20,labels = c("Ctl","Trt"))
weight <- c(ctl,trt)
lm.D9 <- lm(weight~group)
lm.D90 <-lm(weight~group-1) #omitting
anova(lm.D9)
summary(lm.D90)
opar <- par(mfrow=c(2,2),oma=c(0,0,1.1,0))
plot(lm.D9, las=1) #Residuals, Fitted, ...
require(graphics)
library(debug)
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2,10,20,labels = c("Ctl","Trt"))
weight <- c(ctl,trt)
lm.D9 <- lm(weight~group)
lm.D90 <-lm(weight~group-1) #omitting
anova(lm.D9)
summary(lm.D90)
opar <- par(mfrow=c(2,2),oma=c(0,0,1.1,0))
plot(lm.D9, las=1) #Residuals, Fitted, ...
plot(lm.D9, las=1) #Residuals, Fitted, ...
opar <- par(mfrow=c(2,2),oma=c(0,0,1.1,0))
par(opar)
library(debug)
mtrace(lm)
?lm
D(1)
?lm
View(lm)
library(debug)
mtrace(lm)
?lm
debug(lm)
?debug
mtrace(lm)
lm
D(1)
D(1)>
)
x <- c(10,2,7,89,43,1) ## an example vector to try out
ii <- which(x%/%10 > 0) ## indices of the double digits in x?
xs <- rep(0,length(ii)+length(x))
length(ii)
ii+1:length(ii)-
1
ii+1
ii+1:length(ii)
ii+1:length(ii)-1
iis <- ii+1:length(ii)-1
iis <- ii+1:length(ii) ## where should second digit go in xs
1:length(ii)
length(ii)
xs[iis] <- x[ii]%/%10 ## insert 10s digits
iis <- ii+1:length(ii) ## where should second digit go in xs
xs[iis] <- x[ii]%/%10 ## insert 10s digits
ii <- which(nchar(x)>1) ## which elements of x are double digit?
xs <- rep("",length(ii)+length(x)) ## vector to store the single digits
iis <- ii+1:length(ii) ## where should second digit go in xs?
iis <- ii+1:length(ii) ## where should second digit go in xs?
xs[iis] <- substr(x[ii],2,2) ## insert 2nd digits
# Text Processing
poem <- paste("Inside me is a skeleton, of this I have no doubt,",
"now it’s got my flesh on, but it’s waiting to get out.")
pow <- strsplit(poem," ")[[1]] ## vector of poem words
n.words <- length(pow) ## number of words
freq <- tabulate(nchar(pow)) ## count frequency of n-letter words
ie <- grep("e",pow,fixed=TRUE) ## find ‘e’ words
n.e <- length(ie) ## number of ‘e’ words
ia <- grep("a",pow,fixed=TRUE) ## find ‘a’ words
iea <- ia[ia %in% ie] ## find words with ‘e’ and ‘a’
setwd ("D:/Fenanda S2/03 Extended Statistical Program/Latihan Project 1")
a = scan("shakespeare.txt",what="character",skip=83,nlines=196043-83,
fileEncoding="UTF-8")
length(a)
pre_1 <- grep("[",a,fixed=TRUE)
pre_1 <- grep("[",a,fixed=TRUE)
pre_1a = grep("[",a,fixed=TRUE)
pre_1b = grep("]",a,fixed=TRUE)
pre_1a = grep("[",a,fixed=TRUE)
pre_1b = grep("]",a,fixed=TRUE)
pre_1ab = pre_1a[pre_1a %in% pre_1b]
pre_1 = a[!a%in%pre_1a]
length(a)
pre_1 = a[-pre_1a]
963240-4255
setwd ("D:/Fenanda S2/03 Extended Statistical Program/Latihan Project 1")
a = scan("shakespeare.txt",what="character",skip=83,nlines=196043-83,
fileEncoding="UTF-8")
View(a)
pre_1a = grep("[",a,fixed=TRUE)
pre_1b = grep("]",a,fixed=TRUE)
pre_1 = a[-pre_1a]
write.table(pre_1,"shakespeare_ed.txt",sep="\t",row.names=FALSE)
# PROJECT 1 - EXTENDED STATISTICAL PROGRAMMING =================================
# Group 12
# Aseel Alghamdi : S2901228
# Fenanda Dwitha Kurniasari : S2744048
# Nurmawiya : S2822251
# Aseel : Tabulating common words, matrix M preparation, femael.predict
# Fenanda : Removing stage direction, creating next.word & femael.predict
# Nurmawiya : Removing full uppercase & number, creating split_punct & next.word
# Notes :
# Femael.predict function (stands for Fenanda, Nurma, Aseel) allows you to input
# keywords and display the output resulted in next.word (predicted token(s))
# into predicted word(s)
start_ <- Sys.time()
a <- scan("shakespeare.txt",what="character",skip=83,nlines=196043-83,
fileEncoding="UTF-8")
# Removing stage directions
loc_1 <- grep("[",a,fixed=TRUE) #locating open square bracket [
length_a <- length(a)
all_loc <- NULL
for (i in loc_1){
#locating stage directions within next 100 words with close square bracket ]
loc_2 <- grep("]",a[i:min((i+100),length_a)],fixed=TRUE)
#locating full stop (.) for unmatched brackets
loc_3 <- grep(".",a[i:min((i+100),length_a)],fixed=TRUE)
#locating words to exclude
if(length(loc_2)>0){
loc_exc <- c(i:(loc_2[1]+(i)-(1)))
} else{loc_exc <- c(i:(loc_3[1]+(i)-(1)))}
ifelse (i==loc_1[1],
all_loc <- loc_exc,
all_loc <- append(all_loc,loc_exc))
}
#Removing stage directions from a
a <- a[-(all_loc)]
#Removing full-uppercase letter exclude I and A, and removing numbers from a
upnum_loc <- which(toupper(a)==a & !(a %in% c("I", "A")) | grepl("[0-9]", a))
a <- a[-(upnum_loc)]
#Removing underscore, dash, parentheses and asterisk from a
a <- gsub("[*()_-]", "",a)
#Splitting punctuation marks from every word and lowercase
split_punct <- function (x){
punct <- c(",", ".", ";", "!", ":", "?")
for (i in punct) {
x <- gsub(paste0('[', i, ']'), paste0("#", i), x)
}
x <- tolower(unlist(strsplit(x, "[#]", perl = TRUE)))
}
a <- split_punct(a)
write.table(a,"cleaned_a.txt",sep="\t",row.names=FALSE) #preprocess result check
# Tabulating common words
b <- unique(a)
freq <- tabulate(match(a,b))
b <- which(rank(-freq) <= 1000) #average ties method, rank 1 = most common word
#final dataset of b contains indices of top ~1000 words from the unique words
# Preparing M and M1 matrices
b_word <- a[b]
n <- length(a)
mlag <- 4
mrow <- n - mlag
mcol <- mlag + 1
M1 <- match(a,b_word) #M1 = token
M <- matrix(NA, mrow, mcol)
for (i in 0:4) {
M[,i+1] <- M1[(i+1):(mrow+i)]
}
# Predicting the next word tokens
next.word <- function(key, M, M1, w = rep(1, ncol(M) - 1)) {
ii = c()
match.row = c()
k.match <- match(key, b_word)
loc.key <- which(is.finite(k.match))
key.n   <- k.match[loc.key]
# If key > 4, use only the last mlag elements
if (length(key.n) > mlag) key.n <- tail(key.n, mlag)
if (length(key.n) != 0) {
mc <- mlag - (length(key.n) - 1)  # start column
# find matching row
ii <- colSums(!(t(M[, mc:mlag, drop = FALSE]) == key.n))
}
match.row <- which(ii == 0 & is.finite(ii))
# Condition 1 - Token key(s) exactly match with j-th row
if (length(match.row) == 1) {
chosen <- match.row
nxt <- M[chosen, length(key.n) + 1]
nxt.word <- b_word[nxt]
# Condition 2 - Token key(s) match with n j-th row
# Calculate weight each row and sample a row based on weighted probability
} else if (length(match.row) > 1) {
w <- rep(1,length(match.row))
chosen <- sample(match.row, 1, prob = w)
nxt <- M[chosen, length(key.n) + 1]
nxt.word <- b_word[nxt]
# Condition 3 - Token key(s) doesn't match with any row in M
# Calculate weight in M1 and sample a "word" based on weighted probability
} else {
nxt <- sample(M1, 1, prob = rep(1, length(M1)))
nxt.word <- a[nxt]
}
# If nxt.word NA, then sample again M1 and exlude NA based on weighted prob
if (is.na(nxt.word)) {
nxt <- sample(M1[!is.na(M1)], 1, prob = rep(1, sum(!is.na(M1))))
nxt.word <- a[nxt]
}
return(nxt.word)
}
# Keyword(s) input and return the predicted results
set.seed(148)
femael.predict <- function(M, M1) {
repeat {
key <- readline(prompt = "Please input the key: ")
if (length(key) > 0 &&
is.na(suppressWarnings(as.numeric(key))) &&
key!="") {
# Generate words until we reach 5 tokens total
while (length(key) < 5) {
key <- unlist(strsplit(key, " "))
key <- split_punct(key)
nxt.w <- next.word(key, M, M1)
key <- c(key, nxt.w)  # append predicted word
}
cat("The result is:\n")
print(paste(key, collapse = " "))
break #Exit loop if condition is satisfied
} else {
cat("Invalid input. Please input another key.\n")
}
}
}
femael.predict(M,M1)
end_ <- Sys.time()
time_ <- end_ - start_
time_
# PROJECT 1 - EXTENDED STATISTICAL PROGRAMMING =================================
# Group 12
# Aseel Alghamdi : S2901228
# Fenanda Dwitha Kurniasari : S2744048
# Nurmawiya : S2822251
# Aseel : Tabulating common words, matrix M preparation, femael.predict
# Fenanda : Removing stage direction, creating next.word & femael.predict
# Nurmawiya : Removing full uppercase & number, creating split_punct & next.word
# Notes :
# Femael.predict function (stands for Fenanda, Nurma, Aseel) allows you to input
# keywords and display the output resulted in next.word (predicted token(s))
# into predicted word(s)
start_ <- Sys.time()
a <- scan("shakespeare.txt",what="character",skip=83,nlines=196043-83,
fileEncoding="UTF-8")
# Removing stage directions
loc_1 <- grep("[",a,fixed=TRUE) #locating open square bracket [
length_a <- length(a)
all_loc <- NULL
for (i in loc_1){
#locating stage directions within next 100 words with close square bracket ]
loc_2 <- grep("]",a[i:min((i+100),length_a)],fixed=TRUE)
#locating full stop (.) for unmatched brackets
loc_3 <- grep(".",a[i:min((i+100),length_a)],fixed=TRUE)
#locating words to exclude
if(length(loc_2)>0){
loc_exc <- c(i:(loc_2[1]+(i)-(1)))
} else{loc_exc <- c(i:(loc_3[1]+(i)-(1)))}
ifelse (i==loc_1[1],
all_loc <- loc_exc,
all_loc <- append(all_loc,loc_exc))
}
#Removing stage directions from a
a <- a[-(all_loc)]
#Removing full-uppercase letter exclude I and A, and removing numbers from a
upnum_loc <- which(toupper(a)==a & !(a %in% c("I", "A")) | grepl("[0-9]", a))
a <- a[-(upnum_loc)]
#Removing underscore, dash, parentheses and asterisk from a
a <- gsub("[*()_-]", "",a)
#Splitting punctuation marks from every word and lowercase
split_punct <- function (x){
punct <- c(",", ".", ";", "!", ":", "?")
for (i in punct) {
x <- gsub(paste0('[', i, ']'), paste0("#", i), x)
}
x <- tolower(unlist(strsplit(x, "[#]", perl = TRUE)))
}
a <- split_punct(a)
write.table(a,"cleaned_a.txt",sep="\t",row.names=FALSE) #preprocess result check
# Tabulating common words
b <- unique(a)
freq <- tabulate(match(a,b))
b <- which(rank(-freq) <= 1000) #average ties method, rank 1 = most common word
#final dataset of b contains indices of top ~1000 words from the unique words
# Preparing M and M1 matrices
b_word <- a[b]
n <- length(a)
mlag <- 4
mrow <- n - mlag
mcol <- mlag + 1
M1 <- match(a,b_word) #M1 = token
M <- matrix(NA, mrow, mcol)
for (i in 0:4) {
M[,i+1] <- M1[(i+1):(mrow+i)]
}
# Predicting the next word tokens
next.word <- function(key, M, M1, w = rep(1, ncol(M) - 1)) {
ii = c()
match.row = c()
k.match <- match(key, b_word)
loc.key <- which(is.finite(k.match))
key.n   <- k.match[loc.key]
# If key > 4, use only the last mlag elements
if (length(key.n) > mlag) key.n <- tail(key.n, mlag)
if (length(key.n) != 0) {
mc <- mlag - (length(key.n) - 1)  # start column
# find matching row
ii <- colSums(!(t(M[, mc:mlag, drop = FALSE]) == key.n))
}
match.row <- which(ii == 0 & is.finite(ii))
# Condition 1 - Token key(s) exactly match with j-th row
if (length(match.row) == 1) {
chosen <- match.row
nxt <- M[chosen, length(key.n) + 1]
nxt.word <- b_word[nxt]
# Condition 2 - Token key(s) match with n j-th row
# Calculate weight each row and sample a row based on weighted probability
} else if (length(match.row) > 1) {
w <- rep(1,length(match.row))
chosen <- sample(match.row, 1, prob = w)
nxt <- M[chosen, length(key.n) + 1]
nxt.word <- b_word[nxt]
# Condition 3 - Token key(s) doesn't match with any row in M
# Calculate weight in M1 and sample a "word" based on weighted probability
} else {
nxt <- sample(M1, 1, prob = rep(1, length(M1)))
nxt.word <- a[nxt]
}
# If nxt.word NA, then sample again M1 and exlude NA based on weighted prob
if (is.na(nxt.word)) {
nxt <- sample(M1[!is.na(M1)], 1, prob = rep(1, sum(!is.na(M1))))
nxt.word <- a[nxt]
}
return(nxt.word)
}
# Keyword(s) input and return the predicted results
set.seed(148)
femael.predict <- function(M, M1) {
repeat {
key <- readline(prompt = "Please input the key: ")
if (length(key) > 0 &&
is.na(suppressWarnings(as.numeric(key))) &&
key!="") {
# Generate words until we reach 5 tokens total
while (length(key) < 5) {
key <- unlist(strsplit(key, " "))
key <- split_punct(key)
nxt.w <- next.word(key, M, M1)
key <- c(key, nxt.w)  # append predicted word
}
cat("The result is:\n")
print(paste(key, collapse = " "))
break #Exit loop if condition is satisfied
} else {
cat("Invalid input. Please input another key.\n")
}
}
}
femael.predict(M,M1)
end_ <- Sys.time()
time_ <- end_ - start_
time_
# PROJECT 1 - EXTENDED STATISTICAL PROGRAMMING =================================
# Group 12
# Aseel Alghamdi : S2901228
# Fenanda Dwitha Kurniasari : S2744048
# Nurmawiya : S2822251
# Aseel : Tabulating common words, matrix M preparation, femael.predict
# Fenanda : Removing stage direction, creating next.word & femael.predict
# Nurmawiya : Removing full uppercase & number, creating split_punct & next.word
# Notes :
# Femael.predict function (stands for Fenanda, Nurma, Aseel) allows you to input
# keywords and display the output resulted in next.word (predicted token(s))
# into predicted word(s)
a <- scan("shakespeare.txt",what="character",skip=83,nlines=196043-83,
fileEncoding="UTF-8")
# Removing stage directions
loc_1 <- grep("[",a,fixed=TRUE) #locating open square bracket [
length_a <- length(a)
all_loc <- NULL
for (i in loc_1){
#locating stage directions within next 100 words with close square bracket ]
loc_2 <- grep("]",a[i:min((i+100),length_a)],fixed=TRUE)
#locating full stop (.) for unmatched brackets
loc_3 <- grep(".",a[i:min((i+100),length_a)],fixed=TRUE)
#locating words to exclude
if(length(loc_2)>0){
loc_exc <- c(i:(loc_2[1]+(i)-(1)))
} else{loc_exc <- c(i:(loc_3[1]+(i)-(1)))}
ifelse (i==loc_1[1],
all_loc <- loc_exc,
all_loc <- append(all_loc,loc_exc))
}
#Removing stage directions from a
a <- a[-(all_loc)]
#Removing full-uppercase letter exclude I and A, and removing numbers from a
upnum_loc <- which(toupper(a)==a & !(a %in% c("I", "A")) | grepl("[0-9]", a))
a <- a[-(upnum_loc)]
#Removing underscore, dash, parentheses and asterisk from a
a <- gsub("[*()_-]", "",a)
#Splitting punctuation marks from every word and lowercase
split_punct <- function (x){
punct <- c(",", ".", ";", "!", ":", "?")
for (i in punct) {
x <- gsub(paste0('[', i, ']'), paste0("#", i), x)
}
x <- tolower(unlist(strsplit(x, "[#]", perl = TRUE)))
}
a <- split_punct(a)
# Tabulating common words
b <- unique(a)
freq <- tabulate(match(a,b))
b <- which(rank(-freq) <= 1000) #average ties method, rank 1 = most common word
#final dataset of b contains indices of top ~1000 words from the unique words
# Preparing M and M1 matrices
b_word <- a[b]
n <- length(a)
mlag <- 4
mrow <- n - mlag
mcol <- mlag + 1
M1 <- match(a,b_word) #M1 = token
M <- matrix(NA, mrow, mcol)
for (i in 0:4) {
M[,i+1] <- M1[(i+1):(mrow+i)]
}
# Predicting the next word tokens
next.word <- function(key, M, M1, w = rep(1, ncol(M) - 1)) {
ii = c()
match.row = c()
k.match <- match(key, b_word)
loc.key <- which(is.finite(k.match))
key.n   <- k.match[loc.key]
# If key > 4, use only the last mlag elements
if (length(key.n) > mlag) key.n <- tail(key.n, mlag)
if (length(key.n) != 0) {
mc <- mlag - (length(key.n) - 1)  # start column
# find matching row
ii <- colSums(!(t(M[, mc:mlag, drop = FALSE]) == key.n))
}
match.row <- which(ii == 0 & is.finite(ii))
# Condition 1 - Token key(s) exactly match with j-th row
if (length(match.row) == 1) {
chosen <- match.row
nxt <- M[chosen, length(key.n) + 1]
nxt.word <- b_word[nxt]
# Condition 2 - Token key(s) match with n j-th row
# Calculate weight each row and sample a row based on weighted probability
} else if (length(match.row) > 1) {
w <- rep(1,length(match.row))
chosen <- sample(match.row, 1, prob = w)
nxt <- M[chosen, length(key.n) + 1]
nxt.word <- b_word[nxt]
# Condition 3 - Token key(s) doesn't match with any row in M
# Calculate weight in M1 and sample a "word" based on weighted probability
} else {
nxt <- sample(M1, 1, prob = rep(1, length(M1)))
nxt.word <- a[nxt]
}
# If nxt.word = NA, then sample again M1 and exlude NA based on weighted prob
if (is.na(nxt.word)) {
nxt <- sample(M1[!is.na(M1)], 1, prob = rep(1, sum(!is.na(M1))))
nxt.word <- a[nxt]
}
return(nxt.word)
}
# Keyword(s) input and return the predicted results
set.seed(148)
femael.predict <- function(M, M1) {
repeat {
key <- readline(prompt = "Please input the key: ")
if (length(key) > 0 &&
is.na(suppressWarnings(as.numeric(key))) &&
key!="") {
# Generate words until we reach 5 tokens total
while (length(key) < 5) {
key <- unlist(strsplit(key, " "))
key <- split_punct(key)
nxt.w <- next.word(key, M, M1)
key <- c(key, nxt.w)  # append predicted word
}
cat("The result is:\n")
print(paste(key, collapse = " "))
break #Exit loop if condition is satisfied
} else {
cat("Invalid input. Please input another key.\n")
}
}
}
femael.predict(M,M1)

<<<<<<< Updated upstream
<<<<<<< Updated upstream
#store newE for sus_hh if random value < alpha[1]
newE[sus_hh] <- newE[sus_hh] | (runif(length(sus_hh)) < alpha[1])
#using OR logical to accumulate infections, not to reset them
}
# network infections: infect regular contacts from alink
if (length(alink[[i]]) > 0) { #store sus_net if there's regular contacts
#store only the member(s) with regular contacts in S
sus_net <- alink[[i]][state[alink[[i]]] == "S"]
if (length(sus_net) > 0) { #store newE if there's sus_net
#store newE for sus_net if random value < alpha[2]
newE[sus_net] <- newE[sus_net] | (runif(length(sus_net)) < alpha[2])
}
}
# random mixing: infect random susceptible
sus <- which(state == "S") #locating susceptible
if (length(sus) > 0) {
#probability irrespective of household or regular contacts
p_random <- alpha[3]*nc*beta[i]*beta[sus] / (beta_bar^2*(n-1))
#store newE for sus if random value < p_random
newE[sus] <- newE[sus] | (runif(length(sus)) < p_random)
}
}
#update states based on new infections
state[newE & state == "S"] <- "E" #store susceptible who get exposed
state[newI] <- "I" #store exposed to infectious if random value < gamma
state[newR] <- "R" #store infectious to recovered if random value < delta
#record daily counts of each state
seir[t, ] <- tabulate(factor(state, levels=c("S", "E", "I", "R")), nbins=4)
}
#returns a list of elements S, E, I, R
return(data.frame(t = 1:nt, seir))
} ## nseir
# 4) Function Plot
dyn.plot <- function(seir, title = "SEIR Dynamics") {
# Function to create dynamics plot of the simulated population in each states
# x-axis : days to simulate (from 1 to 100)
# y-axis : number of individuals per states
#          explanation of y-axis
#          ---------------------|
#          at the initial day, number of susceptible individual is the largest
#          total individuals in all states S+E+I+R = 1000
#          these numbers would dynamically change day by day in each states
#          depend on the defined models
# input : nseir model from function nseir
# output : Dynamic Plot days vs number of individuals per states
# Plot the states in S(susceptible)
# Create the base plot
plot(seir$t, seir$S, type = "p", ##plot day vs number of susceptible
ylim = c(0, max(seir$S)), xlim = c(0, max(seir$t)), ## set maximum range
xlab = "Days", ylab = "Number of individuals", ##labelling the plot
col = "blue", pch = 1, main = title) ##color and type of points in plot
# Add points for each states
points(seir$t, seir$E, col = "orange", pch = 1) ##add states
points(seir$t, seir$I, col = "red", pch = 1)
points(seir$t, seir$R, col = "darkgreen", pch = 1)
# Add legend
legend(
"right",
legend = c("Susceptible", "Exposed", "Infectious", "Recovered"),
col = c("blue", "orange", "red", "darkgreen"),
pch = 1, bty = "n", ##type of points and no box legend
cex = 0.8,       ## smaller text
pt.cex = 0.8,    ## smaller symbols
y.intersp = 0.6, ## spacing horizontal
x.intersp = 0.4  ## spacing between symbol and text
)
} ## dyn.plot
# 5) Comparing Model
# Setting up beta vector and alink pairs
# beta is vector of n values (n = 1000) ~ U(0,1)
# alink contains list of network made per each person
set.seed(345) ## to ensure we get same vector values of beta for all model
beta <- runif(n); alink <- get.net(beta, nc = 15, h = h)
# Scenario 1: Full model with default parameters
seir1 <- nseir(beta, h, alink)
start <- Sys.time()
# PROJECT 2 - EXTENDED STATISTICAL PROGRAMMING =================================
# Group 12
# Aseel Alghamdi : S2901228
# Fenanda Dwitha Kurniasari : S2744048
# Nurmawiya : S2822251
# Aseel : create n people and its household, contact network, cross-check
#         the entire code and revise code & comments
# Fenanda : create plot function, compare the model, cross-check the entire code
#           and revise code & comments
# Nurmawiya : create nseir function, cross-check code, cross-check the entire
#             code and revise code & comments
# SEIR (Susceptible, Exposed, Infections, Recovered) Model Simulation
# Goals : create a model and how its use to investigate the role of household
#         and network structure on epidemic dynamics.
# 1) Create n people assigned to corresponding household where maximum size is 5
n <- 10000 #population size
hmax <- 5 #maximum household size
#creating n vector of which the number refers to household
#-and the occurrences refers to size of corresponding household
set.seed(1)
sizes <- sample(1:hmax, n, replace = TRUE)
h <- sample(rep(1:length(sizes), times = sizes)[1:n])
# 2) Contact network
get.net <- function (beta, nc=15, h) {
# Function to create links (daily contacts) for each person
# nc: average number of contacts per person, set to 15
# beta: sociability parameter, higher means more likely to form links
# OUTPUT : list of connected networks from each person (output.net)
n <- length(beta) ## calculate total obs of beta, equal to total population
beta_bar <- mean(beta) ## calculate mean of sociability parameter
# Allocate possible connection formed in each individual
output.net <- vector("list", n) ## list to store the result
output.net0 <- integer(n) ## vector to store number of contact made per person
# Make list of n elements which in each element initially has nc subelement
# Later, we would allocate (drop/add sub-element and store possible contact
# Initialise contact list for each person with nc=15 placeholders
for (k in 1:n) output.net[[k]] <- integer(nc) ## set initial value output.net
# Loop over each individual
for (i in 1:(n-1)) {
j <- (i+1):n # generating candidate contacts
flag <- h[i] != h[j]  # flag to filter same household
j <- j[flag] # filter candidates contacts from different household
if (length(j) == 0) next # skip iteration when there are no candidate
# Probability of  a link between persons i and j
p_link <- nc * beta[i] * beta[j] / (beta_bar^2 * (n - 1))
# Select the candidates contacts based on p-link
linked <- j[runif(length(j)) < p_link] #vector possible candidate contacts
# If there is chosen candidate(s), store it into output.net and output.net0
if (length(linked) > 0) {
# Position to fill
pos = (output.net0[i]+1):(output.net0[i]+length(linked))
# Assign link[[i]]to candidates from "linked" at given position
output.net[[i]][pos] <- linked
# Assign number of chosen candidates at i index in output.net0
output.net0[i] <- output.net0[i] + length(linked)
# Vice versa, assign "i" to their linked candidates
for (j1 in linked) {
# Assign i to output.net's of its chosen candidates
output.net[[j1]][output.net0[j1]+1] <- i
# Assign the number of candidates (add by 1) to its chosen candidates
output.net0[j1] <- output.net0[j1] + 1
}
}
## to the next value of i
}
# Drop sub-element/rejected candidates and replace person with no contact
for (k in 1:n) {
if (output.net0[k] > 0) {
# Filter assigned links when chosen number of chosen candidates < nc
output.net[[k]] <- output.net[[k]][1:output.net0[k]]
} else {
# if there is no chosen candidate, replace sub-element into NULL
output.net[[k]] <- integer(0)
}
}
return(output.net)
} ## get.net
# 3) nseir function
nseir <- function(beta, h, alink, alpha=c(.1, .01, .01),
delta=.2, gamma=.4, nc=15, nt=100, pinf=.005){
# SEIR stochastic simulation model
# beta: sociability parameter of each person
# h: household list
# alink: list of regular contacts of each person returned by get.net
# alpha[1]: daily prob i infecting j if in same household (alpha h)
# alpha[2]: daily prob i infecting j if in regular contact (alpha c)
# alpha[3]: daily prob i infecting j through random mixing (alpha r)
# delta: daily prob I -> R
# gamma: daily prob E -> I
# nc: average number of daily contacts for each person
# nt: number of days to simulate
# pinf: proportion of the initial population to randomly start in the I state
# output : nt x 5 matrix contains the number of people across states (S,E,I,R)
#          in each days (from 1st day to nt(100th) day). It depicts the
#          dynamic change in the number of people in each states based on
#          their daily network (from same household and daily contact) and
#          random mixing (Irrespective of household or regular network
#          relations)
n <- length(beta) #population size
state <- rep("S", n) #initialize susceptible
state[sample.int(n, round(pinf * n))] <- "I" #randomly choose initial state I
#state0 = state[sample.int(n, round(pinf * n))]
seir <- matrix(0, nrow = nt, ncol = 4) #set up storage for pop in each state
colnames(seir) <- c("S", "E", "I", "R") #naming the column
beta_bar <- mean(beta) #mean sociability parameter
for (t in 2:nt) { #consider starting from the second day
#simulate over nt days
newE <- logical(n) #to record who becomes exposed
#using random deviates: runif(n)
newI <- (state == "E") & (runif(n) < gamma) #E -> I with prob gamma
newR <- (state == "I") & (runif(n) < delta) #I -> R with prob delta
inf <- which(state == "I") #locating infectious
#Loop over each infectious person to spread infection
for (i in inf) {
# household infections: infect susceptible in same household
hh <- which(h == h[i]) #find everyone in the same household
sus_hh <- hh[state[hh] == "S"] #keep only those who are susceptible
if (length(sus_hh) > 0) { #store newE if there's susceptible
#store newE for sus_hh if random value < alpha[1]
newE[sus_hh] <- newE[sus_hh] | (runif(length(sus_hh)) < alpha[1])
#using OR logical to accumulate infections, not to reset them
}
# network infections: infect regular contacts from alink
if (length(alink[[i]]) > 0) { #store sus_net if there's regular contacts
#store only the member(s) with regular contacts in S
sus_net <- alink[[i]][state[alink[[i]]] == "S"]
if (length(sus_net) > 0) { #store newE if there's sus_net
#store newE for sus_net if random value < alpha[2]
newE[sus_net] <- newE[sus_net] | (runif(length(sus_net)) < alpha[2])
}
}
# random mixing: infect random susceptible
sus <- which(state == "S") #locating susceptible
if (length(sus) > 0) {
#probability irrespective of household or regular contacts
p_random <- alpha[3]*nc*beta[i]*beta[sus] / (beta_bar^2*(n-1))
#store newE for sus if random value < p_random
newE[sus] <- newE[sus] | (runif(length(sus)) < p_random)
}
}
#update states based on new infections
state[newE & state == "S"] <- "E" #store susceptible who get exposed
state[newI] <- "I" #store exposed to infectious if random value < gamma
state[newR] <- "R" #store infectious to recovered if random value < delta
#record daily counts of each state
seir[t, ] <- tabulate(factor(state, levels=c("S", "E", "I", "R")), nbins=4)
seir[1, "S"] <- n-(round(pinf*n))
seir[1, "I"] <- (round(pinf*n))
}
#returns a list of elements S, E, I, R
return(data.frame(t = 1:nt, seir))
} ## nseir
# 4) Function Plot
dyn.plot <- function(seir, title = "SEIR Dynamics") {
# Function to create dynamics plot of the simulated population in each states
# x-axis : days to simulate (from 1 to 100)
# y-axis : number of individuals per states
#          explanation of y-axis
#          ---------------------|
#          at the initial day, number of susceptible individual is the largest
#          total individuals in all states S+E+I+R = 1000
#          these numbers would dynamically change day by day in each states
#          depend on the defined models
# input : nseir model from function nseir
# output : Dynamic Plot days vs number of individuals per states
# Plot the states in S(susceptible)
# Create the base plot
plot(seir$t, seir$S, type = "p", ##plot day vs number of susceptible
ylim = c(0, max(seir$S)), xlim = c(0, max(seir$t)), ## set maximum range
xlab = "Days", ylab = "Number of individuals", ##labelling the plot
col = "blue", pch = 1, main = title) ##color and type of points in plot
# Add points for each states
points(seir$t, seir$E, col = "orange", pch = 1) ##add states
points(seir$t, seir$I, col = "red", pch = 1)
points(seir$t, seir$R, col = "darkgreen", pch = 1)
# Add legend
legend(
"right",
legend = c("Susceptible", "Exposed", "Infectious", "Recovered"),
col = c("blue", "orange", "red", "darkgreen"),
pch = 1, bty = "n", ##type of points and no box legend
cex = 0.8,       ## smaller text
pt.cex = 0.8,    ## smaller symbols
y.intersp = 0.6, ## spacing horizontal
x.intersp = 0.4  ## spacing between symbol and text
)
} ## dyn.plot
# 5) Comparing Model
# Setting up beta vector and alink pairs
# beta is vector of n values (n = 1000) ~ U(0,1)
# alink contains list of network made per each person
set.seed(345) ## to ensure we get same vector values of beta for all model
beta <- runif(n); alink <- get.net(beta, nc = 15, h = h)
# Scenario 1: Full model with default parameters
seir1 <- nseir(beta, h, alink)
# Scenario 2: Random mixing - Setting alpha[1] = alpha[2] = 0 and
#             alpha[3] = 0.04
seir2 <- nseir(beta, h, alink, alpha = c(0, 0, 0.04))
# Scenario 3: Full model with constant beta (beta vector = average beta)
seir3 <- nseir(rep(mean(beta), n), h, alink)
# Scenario 4: Constant beta + random mixing
seir4 <- nseir(rep(mean(beta), n), h, alink, alpha = c(0, 0, 0.04))
# Plot all scenarios
par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))
dyn.plot(seir1, "Full Model Default Parameter")
dyn.plot(seir2, "Random Mixing Only")
dyn.plot(seir3, "Constant Beta")
dyn.plot(seir4, "Constant Beta and Random Mixing")
end <- Sys.time()
end-start
seir1
start <- Sys.time()
## ===============================================================
##        Practical 2 — Social Structure in SEIR Models
## ===============================================================
## What you get:
## (1) make_households()  : build household vector h
## (2) get_net()          : build regular-contact network alink
## (3) nseir()            : SEIR simulator with household/network/random mixing
## (4) plot_seir()        : tidy plotting for S/E/I/R counts
## (5) compare_four()     : runs the four required scenarios + 2x2 plot
## ===============================================================
## -------------------------
## (1) Households generator
## -------------------------
make_households <- function(n, hmax = 5, seed = NULL) {
stopifnot(n >= 1, hmax >= 1)
if (!is.null(seed)) set.seed(seed)
## Build random household sizes ~ Uniform{1,...,hmax} until we reach n
sizes <- integer(0)
while (sum(sizes) < n) sizes <- c(sizes, sample(1:hmax, 1))
if (sum(sizes) > n) sizes[length(sizes)] <- sizes[length(sizes)] - (sum(sizes) - n)
## Assign people to households (household IDs 1..H)
H   <- length(sizes)
ids <- rep(seq_len(H), times = sizes)
h   <- sample(ids, length(ids), replace = FALSE)  # shuffle people across IDs
h
}
## ----------------------------------
## (2) Regular-contact network (alink)
## ----------------------------------
## Returns a list alink where alink[[i]] is the vector of i's regular (non-household) contacts.
## Two methods:
##   - method="exact": create an undirected edge (i,j) with probability
##         p_ij = min(1, nc * beta_i * beta_j / (mean(beta)^2 * (n-1)))
##     for non-household pairs only. This matches the brief exactly but is O(n^2).
##   - method="approx" (default): for each i, sample ~nc partners from non-household
##     candidates with probability ∝ beta_j, adding symmetric edges. This is fast (≈O(n*nc))
##     and yields the intended expected degrees; good for n up to ~10k.
get_net <- function(beta, h, nc = 15, method = c("approx", "exact"), seed = NULL) {
method <- match.arg(method)
if (!is.null(seed)) set.seed(seed)
n <- length(beta); stopifnot(length(h) == n, nc >= 0)
alink <- vector("list", n)
beta_bar <- mean(beta)
if (method == "approx") {
for (i in seq_len(n)) {
cand <- which(h != h[i])
cand <- cand[cand != i]
if (!length(cand)) next
target <- min(nc, length(cand))
if (target == 0) next
pick <- sample(cand, size = target, replace = FALSE, prob = beta[cand])
for (j in pick) {
if (!(j %in% alink[[i]])) alink[[i]] <- c(alink[[i]], j)
if (!(i %in% alink[[j]])) alink[[j]] <- c(alink[[j]], i)
}
}
} else {  # exact Chung–Lu style probability, O(n^2)
c0 <- nc / (beta_bar^2 * (n - 1))
for (i in seq_len(n - 1)) {
cand <- (i + 1):n
cand <- cand[h[cand] != h[i]]             # exclude same-household
if (!length(cand)) next
pij <- pmin(1, c0 * beta[i] * beta[cand]) # edge probs
hits <- runif(length(cand)) < pij
js <- cand[hits]
if (!length(js)) next
alink[[i]] <- c(alink[[i]], js)
for (j in js) alink[[j]] <- c(alink[[j]], i)
}
}
alink
}
## -------------------------------
## (3) SEIR with social structure
## -------------------------------
## states: 1=S, 2=E, 3=I, 4=R
## alpha = c(alpha_h, alpha_c, alpha_r)  (household, network, random mixing)
## delta: P(I -> R) per day
## gamma: P(E -> I) per day
## pinf : initial infected proportion (start directly in I)
nseir <- function(beta, h, alink,
alpha = c(0.1, 0.01, 0.01),
delta = 0.2, gamma = 0.4,
nc = 15, nt = 100, pinf = 0.005,
seed = NULL,
exact_random_mix = FALSE) {
if (!is.null(seed)) set.seed(seed)
n <- length(beta)
stopifnot(length(h) == n, length(alink) == n, length(alpha) == 3)
a_h <- alpha[1]; a_c <- alpha[2]; a_r <- alpha[3]
beta_bar <- mean(beta)
## Initial states
S <- rep(1L, n)
I0 <- sample.int(n, size = max(1L, floor(n * pinf)))
S[I0] <- 3L  # Infectious at t=1
out <- matrix(NA_integer_, nrow = nt, ncol = 4)
colnames(out) <- c("S","E","I","R")
for (t in seq_len(nt)) {
isS <- (S == 1L); isE <- (S == 2L); isI <- (S == 3L)
idxS <- which(isS)
p_hh  <- rep(0, length(idxS))
p_net <- rep(0, length(idxS))
p_mix <- rep(0, length(idxS))
## (A) Household infections: 1 - (1 - a_h)^(# infectious in household)
if (a_h > 0) {
I_counts <- tapply(isI, h, sum)                   # infectious per household
hh_counts <- I_counts[as.character(h[idxS])]
hh_counts[is.na(hh_counts)] <- 0
p_hh <- 1 - (1 - a_h)^(hh_counts)
}
## (B) Regular-network infections: 1 - (1 - a_c)^(# infectious neighbors)
if (a_c > 0) {
isI_num <- as.integer(isI)
kinf <- vapply(alink[idxS], function(v) if (length(v)) sum(isI_num[v]) else 0L, integer(1L))
p_net <- 1 - (1 - a_c)^(kinf)
}
## (C) Random mixing:
## Exact definition: per pair (i in I, j in S), P(i infects j) =
##   a_r * nc * beta_i * beta_j / (beta_bar^2 * (n-1)).
## Combine across all infectives i to get j's overall probability.
if (a_r > 0) {
c0 <- a_r * nc / (beta_bar^2 * (n - 1))
if (!exact_random_mix) {
## Fast hazard approximation: p = 1 - exp(- c0 * beta_j * sum(beta_i over I))
sum_beta_I <- sum(beta[isI])
lam <- c0 * beta[idxS] * sum_beta_I
p_mix <- 1 - exp(-lam)
} else {
## Exact product over infectious set: p = 1 - Π_i (1 - c0 * beta_j * beta_i)
bi <- beta[isI]
for (k in seq_along(idxS)) {
bj <- beta[idxS[k]]
p_mix[k] <- 1 - exp(sum(log1p(-c0 * bj * bi)))
=======
=======
>>>>>>> Stashed changes
if (h[i] != h[j]) { #only connect if they are not in the same household
#prob that i and j have contact (daily link)
p_link <- nc * beta[i] * beta[j] / (beta_bar^2 * (n - 1))
#If daily link of i and j person > random value U(0,1),
#then create a link between i and j
if (runif(1) < p_link) {
links[[i]] <- c(links[[i]], j) #Store j into list who connects with i
links[[j]] <- c(links[[j]], i) #Store i in j's list of contacts
>>>>>>> Stashed changes
}
}
}
## Combine independent channels
p_inf <- 1 - (1 - p_hh) * (1 - p_net) * (1 - p_mix)
p_inf[p_inf < 0] <- 0; p_inf[p_inf > 1] <- 1
## Transitions (synchronous updates)
newE_idx <- idxS[ runif(length(idxS)) < p_inf ]
idxE <- which(isE)
newI_idx <- idxE[ runif(length(idxE)) < gamma ]
idxI <- which(isI)
newR_idx <- idxI[ runif(length(idxI)) < delta ]
if (length(newE_idx)) S[newE_idx] <- 2L
if (length(newI_idx)) S[newI_idx] <- 3L
if (length(newR_idx)) S[newR_idx] <- 4L
out[t,] <- c(sum(S==1L), sum(S==2L), sum(S==3L), sum(S==4L))
}
data.frame(day = 1:nt, out, row.names = NULL)
}
## ----------------
## (4) Nice plotting
## ----------------
plot_seir <- function(res, main = "", legend_pos = "right") {
matplot(res$day, res[,c("S","E","I","R")],
type = "l", lty = 1, lwd = 2, xlab = "Day", ylab = "Population",
main = main, col = 1:4)
legend(legend_pos, bty = "n", legend = c("S","E","I","R"),
lty = 1, lwd = 2, col = 1:4)
}
## -------------------------------
## (5) The four required scenarios
## -------------------------------
## Scenarios:
##   1) Full model with default parameters.
##   2) Remove household + regular network; keep equal average contacts via random mixing:
##        alpha_h = alpha_c = 0, alpha_r = 0.04
##   3) Full model but set beta to its mean (constant sociability).
##   4) Combine (2) and (3): constant beta + random mixing only.
compare_four <- function(n = 3000, hmax = 5, nc = 15, nt = 120,
alpha = c(0.1, 0.01, 0.01),
delta = 0.2, gamma = 0.4, pinf = 0.005,
seed = 1,
net_method = "approx",
mix_exact = FALSE) {
set.seed(seed)
beta <- runif(n, min = 0, max = 1)           # U(0,1) as specified
h    <- make_households(n, hmax)             # households
net  <- get_net(beta, h, nc, method = net_method)  # regular contacts
## 1) Full model
res1 <- nseir(beta, h, net, alpha=alpha, delta=delta, gamma=gamma,
nc=nc, nt=nt, pinf=pinf, exact_random_mix = mix_exact)
## 2) Random mixing only (keep average contacts via a_r = 0.04)
alpha2 <- c(0, 0, 0.04)
res2 <- nseir(beta, h, vector("list", n), alpha=alpha2, delta=delta, gamma=gamma,
nc=nc, nt=nt, pinf=pinf, exact_random_mix = mix_exact)
## 3) Full model, constant beta
beta_bar <- mean(beta)
beta3 <- rep(beta_bar, n)
res3 <- nseir(beta3, h, net, alpha=alpha, delta=delta, gamma=gamma,
nc=nc, nt=nt, pinf=pinf, exact_random_mix = mix_exact)
## 4) Constant beta + random mixing only
res4 <- nseir(beta3, h, vector("list", n), alpha=alpha2, delta=delta, gamma=gamma,
nc=nc, nt=nt, pinf=pinf, exact_random_mix = mix_exact)
## 2x2 plots
op <- par(mfrow=c(2,2), mar=c(4,4,2,1))
on.exit(par(op))
plot_seir(res1, main = "Full model")
plot_seir(res2, main = "Random mixing only (a_r = 0.04)")
plot_seir(res3, main = "Full model, constant beta")
plot_seir(res4, main = "Random mixing + constant beta")
invisible(list(full=res1, rand_only=res2, full_constbeta=res3, rand_constbeta=res4))
}
<<<<<<< Updated upstream
=======
}
}
}
nc=15
for (i in 1:(n-1)) { #loop over person i from 1 to n-1
for (j in (i+1):n) { #loop over person j from i+1 to n to avoid duplicates
if (h[i] != h[j]) { #only connect if they are not in the same household
#prob that i and j have contact (daily link)
p_link <- nc * beta[i] * beta[j] / (beta_bar^2 * (n - 1))
#If daily link of i and j person > random value U(0,1),
#then create a link between i and j
if (runif(1) < p_link) {
links[[i]] <- c(links[[i]], j) #Store j into list who connects with i
links[[j]] <- c(links[[j]], i) #Store i in j's list of contacts
}
}
}
}
return(links) #return the list of daily contacts for each person
n <- length(beta)
beta_bar <- mean(beta) #mean sociability parameter
links <- vector("list", n) #set null vector for links of each person
for (i in 1:(n-1)) { #loop over person i from 1 to n-1
for (j in (i+1):n) { #loop over person j from i+1 to n to avoid duplicates
if (h[i] != h[j]) { #only connect if they are not in the same household
#prob that i and j have contact (daily link)
p_link <- nc * beta[i] * beta[j] / (beta_bar^2 * (n - 1))
#If daily link of i and j person > random value U(0,1),
#then create a link between i and j
if (runif(1) < p_link) {
links[[i]] <- c(links[[i]], j) #Store j into list who connects with i
links[[j]] <- c(links[[j]], i) #Store i in j's list of contacts
}
}
}
}
return(links) #return the list of daily contacts for each person
make_households <- function(n, hmax = 5, seed = NULL) {
stopifnot(n >= 1, hmax >= 1)
if (!is.null(seed)) set.seed(seed)
sizes <- integer(0)
while (sum(sizes) < n) sizes <- c(sizes, sample(1:hmax, 1))
if (sum(sizes) > n) sizes[length(sizes)] <- sizes[length(sizes)] - (sum(sizes) - n)
## Assign people to households (household IDs 1..H)
H   <- length(sizes)
ids <- rep(seq_len(H), times = sizes)
h   <- sample(ids, length(ids), replace = FALSE)  # shuffle people across IDs
h
}
get_net <- function(beta, h, nc = 15, method = c("approx", "exact"), seed = NULL) {
method <- match.arg(method)
if (!is.null(seed)) set.seed(seed)
n <- length(beta); stopifnot(length(h) == n, nc >= 0)
alink <- vector("list", n)
beta_bar <- mean(beta)
if (method == "approx") {
for (i in seq_len(n)) {
cand <- which(h != h[i])
cand <- cand[cand != i]
if (!length(cand)) next
target <- min(nc, length(cand))
if (target == 0) next
pick <- sample(cand, size = target, replace = FALSE, prob = beta[cand])
for (j in pick) {
if (!(j %in% alink[[i]])) alink[[i]] <- c(alink[[i]], j)
if (!(i %in% alink[[j]])) alink[[j]] <- c(alink[[j]], i)
}
}
} else {  # exact Chung–Lu style probability, O(n^2)
c0 <- nc / (beta_bar^2 * (n - 1))
for (i in seq_len(n - 1)) {
cand <- (i + 1):n
cand <- cand[h[cand] != h[i]]             # exclude same-household
if (!length(cand)) next
pij <- pmin(1, c0 * beta[i] * beta[cand]) # edge probs
hits <- runif(length(cand)) < pij
js <- cand[hits]
if (!length(js)) next
alink[[i]] <- c(alink[[i]], js)
for (j in js) alink[[j]] <- c(alink[[j]], i)
}
}
alink
}
nseir <- function(beta, h, alink,
alpha = c(0.1, 0.01, 0.01),
delta = 0.2, gamma = 0.4,
nc = 15, nt = 100, pinf = 0.005,
seed = NULL,
exact_random_mix = FALSE) {
if (!is.null(seed)) set.seed(seed)
n <- length(beta)
stopifnot(length(h) == n, length(alink) == n, length(alpha) == 3)
a_h <- alpha[1]; a_c <- alpha[2]; a_r <- alpha[3]
beta_bar <- mean(beta)
## Initial states
S <- rep(1L, n)
I0 <- sample.int(n, size = max(1L, floor(n * pinf)))
S[I0] <- 3L  # Infectious at t=1
out <- matrix(NA_integer_, nrow = nt, ncol = 4)
colnames(out) <- c("S","E","I","R")
for (t in seq_len(nt)) {
isS <- (S == 1L); isE <- (S == 2L); isI <- (S == 3L)
idxS <- which(isS)
p_hh  <- rep(0, length(idxS))
p_net <- rep(0, length(idxS))
p_mix <- rep(0, length(idxS))
if (a_h > 0) {
I_counts <- tapply(isI, h, sum)                   # infectious per household
hh_counts <- I_counts[as.character(h[idxS])]
hh_counts[is.na(hh_counts)] <- 0
p_hh <- 1 - (1 - a_h)^(hh_counts)
}
if (a_c > 0) {
isI_num <- as.integer(isI)
kinf <- vapply(alink[idxS], function(v) if (length(v)) sum(isI_num[v]) else 0L, integer(1L))
p_net <- 1 - (1 - a_c)^(kinf)
}
f (a_r > 0) {
## ===============================================================
##        Practical 2 — Social Structure in SEIR Models
## ===============================================================
## What you get:
## (1) make_households()  : build household vector h
## (2) get_net()          : build regular-contact network alink
## (3) nseir()            : SEIR simulator with household/network/random mixing
## (4) plot_seir()        : tidy plotting for S/E/I/R counts
## (5) compare_four()     : runs the four required scenarios + 2x2 plot
## ===============================================================
## -------------------------
## (1) Households generator
## -------------------------
make_households <- function(n, hmax = 5, seed = NULL) {
stopifnot(n >= 1, hmax >= 1)
if (!is.null(seed)) set.seed(seed)
## Build random household sizes ~ Uniform{1,...,hmax} until we reach n
sizes <- integer(0)
while (sum(sizes) < n) sizes <- c(sizes, sample(1:hmax, 1))
if (sum(sizes) > n) sizes[length(sizes)] <- sizes[length(sizes)] - (sum(sizes) - n)
## Assign people to households (household IDs 1..H)
H   <- length(sizes)
ids <- rep(seq_len(H), times = sizes)
h   <- sample(ids, length(ids), replace = FALSE)  # shuffle people across IDs
h
}
## ----------------------------------
## (2) Regular-contact network (alink)
## ----------------------------------
## Returns a list alink where alink[[i]] is the vector of i's regular (non-household) contacts.
## Two methods:
##   - method="exact": create an undirected edge (i,j) with probability
##         p_ij = min(1, nc * beta_i * beta_j / (mean(beta)^2 * (n-1)))
##     for non-household pairs only. This matches the brief exactly but is O(n^2).
##   - method="approx" (default): for each i, sample ~nc partners from non-household
##     candidates with probability ∝ beta_j, adding symmetric edges. This is fast (≈O(n*nc))
##     and yields the intended expected degrees; good for n up to ~10k.
get_net <- function(beta, h, nc = 15, method = c("approx", "exact"), seed = NULL) {
method <- match.arg(method)
if (!is.null(seed)) set.seed(seed)
n <- length(beta); stopifnot(length(h) == n, nc >= 0)
alink <- vector("list", n)
beta_bar <- mean(beta)
if (method == "approx") {
for (i in seq_len(n)) {
cand <- which(h != h[i])
cand <- cand[cand != i]
if (!length(cand)) next
target <- min(nc, length(cand))
if (target == 0) next
pick <- sample(cand, size = target, replace = FALSE, prob = beta[cand])
for (j in pick) {
if (!(j %in% alink[[i]])) alink[[i]] <- c(alink[[i]], j)
if (!(i %in% alink[[j]])) alink[[j]] <- c(alink[[j]], i)
}
}
} else {  # exact Chung–Lu style probability, O(n^2)
c0 <- nc / (beta_bar^2 * (n - 1))
for (i in seq_len(n - 1)) {
cand <- (i + 1):n
cand <- cand[h[cand] != h[i]]             # exclude same-household
if (!length(cand)) next
pij <- pmin(1, c0 * beta[i] * beta[cand]) # edge probs
hits <- runif(length(cand)) < pij
js <- cand[hits]
if (!length(js)) next
alink[[i]] <- c(alink[[i]], js)
for (j in js) alink[[j]] <- c(alink[[j]], i)
}
}
alink
}
## -------------------------------
## (3) SEIR with social structure
## -------------------------------
## states: 1=S, 2=E, 3=I, 4=R
## alpha = c(alpha_h, alpha_c, alpha_r)  (household, network, random mixing)
## delta: P(I -> R) per day
## gamma: P(E -> I) per day
## pinf : initial infected proportion (start directly in I)
nseir <- function(beta, h, alink,
alpha = c(0.1, 0.01, 0.01),
delta = 0.2, gamma = 0.4,
nc = 15, nt = 100, pinf = 0.005,
seed = NULL,
exact_random_mix = FALSE) {
if (!is.null(seed)) set.seed(seed)
n <- length(beta)
stopifnot(length(h) == n, length(alink) == n, length(alpha) == 3)
a_h <- alpha[1]; a_c <- alpha[2]; a_r <- alpha[3]
beta_bar <- mean(beta)
## Initial states
S <- rep(1L, n)
I0 <- sample.int(n, size = max(1L, floor(n * pinf)))
S[I0] <- 3L  # Infectious at t=1
out <- matrix(NA_integer_, nrow = nt, ncol = 4)
colnames(out) <- c("S","E","I","R")
for (t in seq_len(nt)) {
isS <- (S == 1L); isE <- (S == 2L); isI <- (S == 3L)
idxS <- which(isS)
p_hh  <- rep(0, length(idxS))
p_net <- rep(0, length(idxS))
p_mix <- rep(0, length(idxS))
## (A) Household infections: 1 - (1 - a_h)^(# infectious in household)
if (a_h > 0) {
I_counts <- tapply(isI, h, sum)                   # infectious per household
hh_counts <- I_counts[as.character(h[idxS])]
hh_counts[is.na(hh_counts)] <- 0
p_hh <- 1 - (1 - a_h)^(hh_counts)
}
## (B) Regular-network infections: 1 - (1 - a_c)^(# infectious neighbors)
if (a_c > 0) {
isI_num <- as.integer(isI)
kinf <- vapply(alink[idxS], function(v) if (length(v)) sum(isI_num[v]) else 0L, integer(1L))
p_net <- 1 - (1 - a_c)^(kinf)
}
## (C) Random mixing:
## Exact definition: per pair (i in I, j in S), P(i infects j) =
##   a_r * nc * beta_i * beta_j / (beta_bar^2 * (n-1)).
## Combine across all infectives i to get j's overall probability.
if (a_r > 0) {
c0 <- a_r * nc / (beta_bar^2 * (n - 1))
if (!exact_random_mix) {
## Fast hazard approximation: p = 1 - exp(- c0 * beta_j * sum(beta_i over I))
sum_beta_I <- sum(beta[isI])
lam <- c0 * beta[idxS] * sum_beta_I
p_mix <- 1 - exp(-lam)
} else {
## Exact product over infectious set: p = 1 - Π_i (1 - c0 * beta_j * beta_i)
bi <- beta[isI]
for (k in seq_along(idxS)) {
bj <- beta[idxS[k]]
p_mix[k] <- 1 - exp(sum(log1p(-c0 * bj * bi)))
}
}
}
## Combine independent channels
p_inf <- 1 - (1 - p_hh) * (1 - p_net) * (1 - p_mix)
p_inf[p_inf < 0] <- 0; p_inf[p_inf > 1] <- 1
## Transitions (synchronous updates)
newE_idx <- idxS[ runif(length(idxS)) < p_inf ]
idxE <- which(isE)
newI_idx <- idxE[ runif(length(idxE)) < gamma ]
idxI <- which(isI)
newR_idx <- idxI[ runif(length(idxI)) < delta ]
if (length(newE_idx)) S[newE_idx] <- 2L
if (length(newI_idx)) S[newI_idx] <- 3L
if (length(newR_idx)) S[newR_idx] <- 4L
out[t,] <- c(sum(S==1L), sum(S==2L), sum(S==3L), sum(S==4L))
}
data.frame(day = 1:nt, out, row.names = NULL)
}
## ----------------
## (4) Nice plotting
## ----------------
plot_seir <- function(res, main = "", legend_pos = "right") {
matplot(res$day, res[,c("S","E","I","R")],
type = "l", lty = 1, lwd = 2, xlab = "Day", ylab = "Population",
main = main, col = 1:4)
legend(legend_pos, bty = "n", legend = c("S","E","I","R"),
lty = 1, lwd = 2, col = 1:4)
}
## -------------------------------
## (5) The four required scenarios
## -------------------------------
## Scenarios:
##   1) Full model with default parameters.
##   2) Remove household + regular network; keep equal average contacts via random mixing:
##        alpha_h = alpha_c = 0, alpha_r = 0.04
##   3) Full model but set beta to its mean (constant sociability).
##   4) Combine (2) and (3): constant beta + random mixing only.
compare_four <- function(n = 3000, hmax = 5, nc = 15, nt = 120,
alpha = c(0.1, 0.01, 0.01),
delta = 0.2, gamma = 0.4, pinf = 0.005,
seed = 1,
net_method = "approx",
mix_exact = FALSE) {
set.seed(seed)
beta <- runif(n, min = 0, max = 1)           # U(0,1) as specified
h    <- make_households(n, hmax)             # households
net  <- get_net(beta, h, nc, method = net_method)  # regular contacts
## 1) Full model
res1 <- nseir(beta, h, net, alpha=alpha, delta=delta, gamma=gamma,
nc=nc, nt=nt, pinf=pinf, exact_random_mix = mix_exact)
## 2) Random mixing only (keep average contacts via a_r = 0.04)
alpha2 <- c(0, 0, 0.04)
res2 <- nseir(beta, h, vector("list", n), alpha=alpha2, delta=delta, gamma=gamma,
nc=nc, nt=nt, pinf=pinf, exact_random_mix = mix_exact)
## 3) Full model, constant beta
beta_bar <- mean(beta)
beta3 <- rep(beta_bar, n)
res3 <- nseir(beta3, h, net, alpha=alpha, delta=delta, gamma=gamma,
nc=nc, nt=nt, pinf=pinf, exact_random_mix = mix_exact)
## 4) Constant beta + random mixing only
res4 <- nseir(beta3, h, vector("list", n), alpha=alpha2, delta=delta, gamma=gamma,
nc=nc, nt=nt, pinf=pinf, exact_random_mix = mix_exact)
## 2x2 plots
op <- par(mfrow=c(2,2), mar=c(4,4,2,1))
on.exit(par(op))
plot_seir(res1, main = "Full model")
plot_seir(res2, main = "Random mixing only (a_r = 0.04)")
plot_seir(res3, main = "Full model, constant beta")
plot_seir(res4, main = "Random mixing + constant beta")
invisible(list(full=res1, rand_only=res2, full_constbeta=res3, rand_constbeta=res4))
}
<<<<<<< Updated upstream
>>>>>>> Stashed changes
=======
>>>>>>> Stashed changes
## --------------------------
## (Optional) quick smoke test
## --------------------------
# source("practical2_seir.R")
# out <- compare_four(n=2000, hmax=5, nc=15, nt=100, seed=42,
#                     net_method="approx", mix_exact=FALSE)
# str(out$full)
## ----------
## Team note:
## ----------
## - Aseel Alghamdi(S2901228): households + network +nseir core
## - Fenanda Dwitha Kurniasari(S2744048):  vectorization checks  +plotting + scenarios + report
## - Nurmawiya(S2822251): plotting + scenarios + report
## ===============================================================
<<<<<<< Updated upstream
<<<<<<< Updated upstream
compare_four (n=10000, hmax=5, nc=15, nt=100, alpha = c(0.1, 0.01, 0.01),
delta = 0.2, gamma = 0.4, pinf = 0.005, seed = 1,
net_method = "approx", mix_exact = FALSE)
end <- Sys.time()
end-start
=======
=======
>>>>>>> Stashed changes
source("practical2_seir.R")
make_households <- function(n=1000, hmax = 5, seed = NULL) {
stopifnot(n >= 1, hmax >= 1)
if (!is.null(seed)) set.seed(seed)
## Build random household sizes ~ Uniform{1,...,hmax} until we reach n
sizes <- integer(0)
while (sum(sizes) < n) sizes <- c(sizes, sample(1:hmax, 1))
if (sum(sizes) > n) sizes[length(sizes)] <- sizes[length(sizes)] - (sum(sizes) - n)
## Assign people to households (household IDs 1..H)
H   <- length(sizes)
ids <- rep(seq_len(H), times = sizes)
h   <- sample(ids, length(ids), replace = FALSE)  # shuffle people across IDs
h
}
poem <- paste("Inside me is a skeleton, of this I have no doubt,",
"now it’s got my flesh on, but it’s waiting to get out.")
poem <- paste("Inside me is a skeleton, of this I have no doubt,",
"now it’s got my flesh on, but it’s waiting to get out.")
pow <- strsplit(poem," ")[[1]] ## vector of poem words
pow
n.words <- length(pow) ## number of words
n.words
n.words <- length(poew) ## number of words
n.words <- length(poem) ## number of words
n.words
n.words <- length(pow) ## number of words
n.words
freq <- tabulate(nchar(pow)) ## count frequency of n-letter words
freq
<<<<<<< Updated upstream
>>>>>>> Stashed changes
=======
>>>>>>> Stashed changes
